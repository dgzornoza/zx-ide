import { Disposable } from '@core/abstractions/disposable';
import { WorkspaceHelpers } from '@core/helpers/workspace-helpers';
import { OutputChannelService } from '@core/services/output-channel.service';
import { Types } from '@core/types';
import { BUILD_DIRECTORY } from '@z88dk/infrastructure';
import { inject, injectable } from 'inversify';
import * as vscode from 'vscode';

export enum MapFileSymbols {
  CRT_ORG_CODE = 'CRT_ORG_CODE',
  __code_compiler_size = '__code_compiler_size',
  __data_compiler_size = '__data_compiler_size',
  __rodata_compiler_size = '__rodata_compiler_size',
  __bss_compiler_size = '__bss_compiler_size',
  __code_user_size = '__code_user_size',
  __data_user_size = '__data_user_size',
  __rodata_user_size = '__rodata_user_size',
  __bss_user_size = '__bss_user_size',
  __BSS_END_tail = '__BSS_END_tail',
  __register_sp = '__register_sp',
  CRT_MAX_HEAP_ADDRESS = 'CRT_MAX_HEAP_ADDRESS',
  __crt_stack_size = '__crt_stack_size',
}

interface ReportData {
  startAddress?: number;
  compilerCodeSize?: number;
  compilerDataSize?: number;
  compilerRoDataSize?: number;
  compilerBssSize?: number;
  userCodeSize?: number;
  userDataSize?: number;
  userRoDataSize?: number;
  userBssSize?: number;
  totalCompiledCode?: number;
  topStack?: number;
  stackSize?: number;
  heapStart?: number;
  usedMemory?: number;
  freeMemory?: number;
}

/**
 * Service to show the report of the .map file generated by the z88dk compiler
 */
@injectable()
export class Z88dkReportService extends Disposable {
  constructor(@inject(Types.OutputChannelService) private outputChannelService: OutputChannelService) {
    super();
  }

  public async showMapFileReport(): Promise<void> {
    const outputChannel = this.outputChannelService.getDefaultOutputChannel();
    outputChannel.show(true);
    outputChannel.clear();

    const reportData = await this.readReportData();
    if (!reportData) {
      outputChannel.appendLine(vscode.l10n.t('ouput .map file not found for analysis'));
      return;
    }

    outputChannel.appendLine(vscode.l10n.t('---------- Z88DK Build report -------------'));

    this.writeFormattedOuputLine(outputChannel, vscode.l10n.t('Program start address:'), reportData.startAddress);
    outputChannel.appendLine('');

    outputChannel.appendLine(vscode.l10n.t('Compiled Code:'));
    this.writeFormattedOuputLine(outputChannel, `\t${vscode.l10n.t('Code size:')}`, reportData.compilerCodeSize);
    this.writeFormattedOuputLine(outputChannel, `\t${vscode.l10n.t('Data size:')}`, reportData.compilerDataSize);
    this.writeFormattedOuputLine(outputChannel, `\t${vscode.l10n.t('Readonly data size:')}`, reportData.compilerRoDataSize);
    this.writeFormattedOuputLine(outputChannel, `\t${vscode.l10n.t('Block started by symbol size:')}`, reportData.compilerBssSize);
    this.writeFormattedOuputLine(outputChannel, `\t${vscode.l10n.t('User code size:')}`, reportData.userCodeSize);
    this.writeFormattedOuputLine(outputChannel, `\t${vscode.l10n.t('User data size:')}`, reportData.userDataSize);
    this.writeFormattedOuputLine(outputChannel, `\t${vscode.l10n.t('Readonly user data size:')}`, reportData.userRoDataSize);
    this.writeFormattedOuputLine(outputChannel, `\t${vscode.l10n.t('User block started by symbol size:')}`, reportData.userBssSize);
    this.writeFormattedOuputLine(outputChannel, `\t${vscode.l10n.t('Total Compiled:')}`, reportData.totalCompiledCode);
    outputChannel.appendLine('');

    this.writeFormattedOuputLine(outputChannel, vscode.l10n.t('Heap starts at:'), reportData.heapStart);
    this.writeFormattedOuputLine(outputChannel, vscode.l10n.t('Stack starts at (down):'), reportData.topStack);
    this.writeFormattedOuputLine(outputChannel, vscode.l10n.t('Stack size:'), reportData.stackSize);
    outputChannel.appendLine('');

    outputChannel.appendLine(' '.repeat(50) + '===============');
    this.writeFormattedOuputLine(outputChannel, vscode.l10n.t('Used memory:'), reportData.usedMemory);
    this.writeFormattedOuputLine(outputChannel, vscode.l10n.t('Free memory:'), reportData.freeMemory);
  }

  private async readReportData(): Promise<ReportData | undefined> {
    const outputFilename = await this.getOutputFilename();
    const mapFileContent = await WorkspaceHelpers.readWorkspaceFile(`${BUILD_DIRECTORY}`, `${outputFilename}.map`);

    var result: ReportData | undefined;
    if (mapFileContent) {
      const symbols = this.parseSymbolsFromContent(mapFileContent);

      const startAddress = symbols[MapFileSymbols.CRT_ORG_CODE];
      const bssEndTail = symbols[MapFileSymbols.__BSS_END_tail];

      // if stack size is invalid, set to undefined
      let stackSize = symbols[MapFileSymbols.__crt_stack_size];
      if (stackSize === undefined || stackSize > 0xffffffff) {
        stackSize = undefined;
      }

      // Stack pointer register or max heap address if not found or invalid value
      let registerSp = symbols[MapFileSymbols.__register_sp];
      if (registerSp === undefined || registerSp > 0xffffffff) {
        registerSp = symbols[MapFileSymbols.CRT_MAX_HEAP_ADDRESS];
      }

      result = {
        startAddress: startAddress,

        compilerCodeSize: symbols[MapFileSymbols.__code_compiler_size],
        compilerDataSize: symbols[MapFileSymbols.__data_compiler_size],
        compilerRoDataSize: symbols[MapFileSymbols.__rodata_compiler_size],
        compilerBssSize: symbols[MapFileSymbols.__bss_compiler_size],

        userCodeSize: symbols[MapFileSymbols.__code_user_size],
        userDataSize: symbols[MapFileSymbols.__data_user_size],
        userRoDataSize: symbols[MapFileSymbols.__rodata_user_size],
        userBssSize: symbols[MapFileSymbols.__bss_user_size],

        topStack: registerSp,
        stackSize: stackSize,
        heapStart: bssEndTail,

        // Bytes occupied from start (CRT_ORG_CODE) to BSS_END (heap start)
        usedMemory: startAddress !== undefined && bssEndTail !== undefined ? bssEndTail - startAddress : undefined,
        // Bytes occupied before stack = all sections from load to BSS_END (heap start)
        freeMemory: registerSp !== undefined && bssEndTail !== undefined ? registerSp - bssEndTail : undefined,
      };

      result.totalCompiledCode =
        result.compilerCodeSize! +
        result.compilerDataSize! +
        result.compilerRoDataSize! +
        result.compilerBssSize! +
        result.userCodeSize! +
        result.userDataSize! +
        result.userRoDataSize! +
        result.userBssSize!;
    }

    return result;
  }

  private writeFormattedOuputLine(outputChannel: vscode.OutputChannel, description: string, value: number | undefined): void {
    let formattedValue = value || value == 0 ? `${value} (0x${value.toString(16).toUpperCase()}) bytes` : 'N/A';
    const padding = ' '.repeat(50 - description.length);
    outputChannel.appendLine(`${description}${padding}${formattedValue}`);
  }

  private async getOutputFilename(): Promise<string | undefined> {
    const content = await WorkspaceHelpers.readWorkspaceFile('Makefile');
    const match = content?.match(/^EXEC_OUTPUT\s*=\s*([\w-]+)/m);
    return match ? match[1] : undefined;
  }

  private parseSymbolsFromContent(mapFileContent: string): Partial<Record<MapFileSymbols, number>> {
    const symbols: Partial<Record<MapFileSymbols, number>> = {};

    const mapFileRegexp = /^(?<name>[A-Za-z0-9_]+)\s+=\s+\$(?<hex>[0-9A-Fa-f]+)/;

    for (const line of mapFileContent.split(/\r?\n/)) {
      const match = mapFileRegexp.exec(line);
      const name = match?.groups?.name as MapFileSymbols | undefined;
      const hex = match?.groups?.hex;

      if (name !== undefined && hex !== undefined && Object.values(MapFileSymbols).includes(name as MapFileSymbols)) {
        symbols[name] = parseInt(hex, 16);
      }
    }

    return symbols;
  }
}
