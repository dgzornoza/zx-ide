import { Disposable } from '@core/abstractions/disposable';
import { FileHelpers } from '@core/helpers/file-helpers';
import { OutputChannelService } from '@core/services/output-channel.service';
import { Types } from '@core/types';
import { inject, injectable } from 'inversify';
import * as vscode from 'vscode';

/**
 * Service to show the report of the .map file generated by the z88dk compiler
 */
@injectable()
export class Z88dkReportService extends Disposable {
  constructor(@inject(Types.OutputChannelService) private outputChannelService: OutputChannelService) {
    super();
  }

  public async showMapFileReport(): Promise<void> {
    const outputFilename = await this.getOutputFilename();
    const mapfileContent = await FileHelpers.readFile('build', `${outputFilename}.map`);
    const outputChannel = this.outputChannelService.getDefaultOutputChannel();
    outputChannel.show(true);

    if (!mapfileContent) {
      outputChannel.appendLine(vscode.l10n.t('ouput .map file not found for analysis'));
      return;
    }

    outputChannel.appendLine(vscode.l10n.t('---------- Z88DK Build report -------------'));

    // C code
    const codeSize = this.extractHexValue(mapfileContent, /^__code_compiler_size\s+=\s+\$(\w+)/m);
    this.writeFormattedOuputLine(outputChannel, vscode.l10n.t('Compiled code size:'), codeSize);

    const dataSize = this.extractHexValue(mapfileContent, /^__data_compiler_size\s+=\s+\$(\w+)/m);
    this.writeFormattedOuputLine(outputChannel, vscode.l10n.t('Compiled data size:'), dataSize);

    const roDataSize = this.extractHexValue(mapfileContent, /^__rodata_compiler_size\s+=\s+\$(\w+)/m);
    this.writeFormattedOuputLine(outputChannel, vscode.l10n.t('Compiled readonly data size:'), roDataSize);

    const bssSize = this.extractHexValue(mapfileContent, /^__bss_compiler_size\s+=\s+\$(\w+)/m);
    this.writeFormattedOuputLine(outputChannel, vscode.l10n.t('Compiled block started by symbol size:'), bssSize);

    // ASM code
    const userCodeSize = this.extractHexValue(mapfileContent, /^__code_user_size\s+=\s+\$(\w+)/m);
    this.writeFormattedOuputLine(outputChannel, vscode.l10n.t('Compiled user code size:'), userCodeSize);

    const userDataSize = this.extractHexValue(mapfileContent, /^__data_user_size\s+=\s+\$(\w+)/m);
    this.writeFormattedOuputLine(outputChannel, vscode.l10n.t('Compiled user data size:'), userDataSize);

    const userRoDataSize = this.extractHexValue(mapfileContent, /^__rodata_user_size\s+=\s+\$(\w+)/m);
    this.writeFormattedOuputLine(outputChannel, vscode.l10n.t('Compiled readonly user data size:'), userRoDataSize);

    const userBssSize = this.extractHexValue(mapfileContent, /^__bss_user_size\s+=\s+\$(\w+)/m);
    this.writeFormattedOuputLine(outputChannel, vscode.l10n.t('Compiled user block started by symbol size:'), userBssSize);

    // summary
    let regSp: number | undefined = this.extractHexValue(mapfileContent, /^__register_sp\s+=\s+\$(\w+)/m);
    regSp = regSp > 0xFFFFFFFF ? undefined : regSp; // regSp in some compilers is bad calculated
    const bssEnd = this.extractHexValue(mapfileContent, /^__BSS_END_tail\s+=\s+\$(\w+)/m);
    const stackSize = this.extractHexValue(mapfileContent, /^TAR__crt_stack_size\s+=\s+\$(\w+)/m);

    const topStack = regSp ? regSp - stackSize : undefined;
    const freeMemory = topStack ? topStack - bssEnd : undefined;

    this.writeFormattedOuputLine(outputChannel, vscode.l10n.t('Stack comes down to :'), topStack);
    this.writeFormattedOuputLine(outputChannel, vscode.l10n.t('Heap starts at:'), bssEnd);
    outputChannel.appendLine(' '.repeat(50) + '===============');
    this.writeFormattedOuputLine(outputChannel, vscode.l10n.t('Free memory:'), freeMemory);
  }

  private extractHexValue(content: string, regex: RegExp): number {
    const match = content.match(regex);
    return match ? parseInt(match[1], 16) : 0;
  }

  private writeFormattedOuputLine(outputChannel: vscode.OutputChannel, description: string, value: number | undefined): void {
    let formattedValue = value || value == 0 ? `${value} (0x${value.toString(16).toUpperCase()}) bytes` : 'N/A';
    const padding = ' '.repeat(50 - description.length);
    outputChannel.appendLine(`${description}${padding}${formattedValue}`);
  }

  private async getOutputFilename(): Promise<string | undefined> {
    const content = await FileHelpers.readFile('Makefile');
    const match = content?.match(/^EXEC_OUTPUT\s*=\s*(\w+)/m);
    return match ? match[1] : undefined;
  }
}
